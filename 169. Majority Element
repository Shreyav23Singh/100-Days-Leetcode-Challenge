Leetcode 169. Majority Element

// Brute force approach

class Solution {
    public int majorityElement(int[] nums) {

        int n = nums.length;

        for(int i=0 ; i<n ; i++){
            int count = 0;

            for(int j = 0 ; j< n ; j++){
                if(nums[j] == nums[i]){
                    count++;
                }

                if(count > n/2)
                return nums[i];
            }
        }
        return -1;
        
    }
}

________________________________________________________________________________________________________________________________________________________________

The Boyerâ€“Moore Voting Algorithm is a clever algorithm to find the majority element (the element that appears more than âŒŠn/2âŒ‹ times) in O(n) time and O(1) space.
ğŸ”¹ Intuition

âœ…ğŸ§‘ğŸ»â€ğŸ’»Think of it as a voting system:

Each element in the array is like a "vote".

The majority element will always have more than half of the total votes.

We keep a candidate and a count:

If count is 0, we pick the current number as our candidate.

If the current number is the same as the candidate, increment the count.

Otherwise, decrement the count.

At the end, the candidate will be the majority element.
----------------------------------------------------------------------------------------------
ğŸ”¹ Steps

Initialize:

candidate = 0

count = 0

Traverse the array:

If count == 0, set candidate = num

If num == candidate, increment count

Else, decrement count

Return candidate (problem guarantees majority element exists).

ğŸ”¹ Example Walkthrough

nums = [3, 2, 3]

Start: candidate = 0, count = 0

First element 3:
count == 0 â†’ candidate = 3
count = 1

Second element 2:
num != candidate â†’ count = 0

Third element 3:
count == 0 â†’ candidate = 3
count = 1

âœ… Final candidate = 3 â†’ Majority element.
----------------------------------------------------------------------------------------------

Code ğŸ‘©ğŸ»â€ğŸ’»ğŸ§‘ğŸ»â€ğŸ’»ğŸ’«âœ…
class Solution {
    public int majorityElement(int[] nums) {

        int candidate = 0 , count = 0;


        for(int currentNumber : nums){
            if(count == 0){
                candidate = currentNumber;
            }

            count += (candidate == currentNumber) ? 1 : -1 ;

        }
        return candidate;
        
    }
}

In O(n) time and O(1) space.

____________________________________________________________________Hashmap____________________________________________________________________________________________
ğŸ”¹ Why HashMap?

The intent is simple:
â¡ï¸ A HashMap lets us keep track of how many times each element appears in the array.

So instead of brute force (where you check frequency by scanning the array again and again), we use a HashMap to store counts as we go.

ğŸ”¹ Step-by-step intent

Take nums = [2,2,1,1,1,2,2]

Create an empty HashMap<Integer, Integer> â†’ map

Traverse the array:

For each number, increase its count in the map:

map.put(num, map.getOrDefault(num, 0) + 1);

While updating, check if this elementâ€™s frequency exceeds n/2.

If yes â†’ return immediately.

If not, continue.

At the end, the number with count > n/2 is your majority element.

ğŸ”¹ Example Dry Run

nums = [3, 2, 3]

Initially: map = {}

Process 3 â†’ map = {3=1}

Process 2 â†’ map = {3=1, 2=1}

Process 3 â†’ map = {3=2, 2=1}

Check: count of 3 = 2 > n/2 = 1.5 â†’ Majority = 3

ğŸ”¹ Pros & Cons of HashMap

âœ… Easy to understand, very intuitive
âœ… Works for arrays where a majority element may not exist (we can modify to return -1 if no element > n/2)

âŒ Uses O(n) extra space (not optimal compared to Boyerâ€“Moore)
âŒ Slightly slower because of map operations

ğŸ’«ğŸ’«ğŸ’«CodeğŸ’«ğŸ’«ğŸ’«
class Solution {
    public int majorityElement(int[] nums) {

        int n= nums.length;

        HashMap<Integer, Integer> map = new HashMap<>(); // Int == element , Integer = Count no of times ele appear

        for(int ele : nums){
            map.put(ele , map.getOrDefault(ele, 0) + 1); //  Update the count of ele in the map.

// map.getOrDefault(ele, 0) â†’ get the current count if it exists, otherwise use 0.

/ Then add 1 to it.

// Finally, put updates the map with the new count.

// ğŸ‘‰ This single line replaces a long if-else:

            if(map.get(ele) > n/2){
                return ele;
            }
        }
        return -1;


        
    }
}
